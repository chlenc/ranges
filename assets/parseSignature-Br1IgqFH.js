import{A as Z,m as A,n as ee,I as te,o as S,q as ne,r as ae,t as se,u as b,v as re,x as oe,y as ie,z as ce,C as ue,D as de,F as le,G as fe,J as he,L as D,K as G,f as pe,M as we,N as H,O as me,P as ge,B as v,Q as M,R as E,S as V,V as ye,W as be,X as Te,Y as Ce,Z as xe,_ as P,$ as Ee,e as j,a0 as Ne,a1 as ve,a2 as k,a3 as W,a4 as ze,a5 as Me,a6 as $,i as Ie,s as Re,a7 as Se,a8 as Pe,a9 as _e,aa as ke,ab as Ae}from"./index-MjOix_bB.js";function De(e,t){if(e.length!==t.length)throw new Z({expectedLength:e.length,givenLength:t.length});const r=[];for(let n=0;n<e.length;n++){const d=e[n],u=t[n];r.push(K(d,u))}return A(r)}function K(e,t,r=!1){if(e==="address"){const o=t;if(!ee(o))throw new te({address:o});return S(o.toLowerCase(),{size:r?32:null})}if(e==="string")return ne(t);if(e==="bytes")return t;if(e==="bool")return S(ae(t),{size:r?32:1});const n=e.match(se);if(n){const[o,a,l="256"]=n,f=Number.parseInt(l,10)/8;return b(t,{size:r?32:f,signed:a==="int"})}const d=e.match(re);if(d){const[o,a]=d;if(Number.parseInt(a,10)!==(t.length-2)/2)throw new oe({expectedSize:Number.parseInt(a,10),givenSize:(t.length-2)/2});return S(t,{dir:"right",size:r?32:null})}const u=e.match(ie);if(u&&Array.isArray(t)){const[o,a]=u,l=[];for(let f=0;f<t.length;f++)l.push(K(a,t[f],!0));return l.length===0?"0x":A(l)}throw new ce(e)}function Fe({chain:e,currentChainId:t}){if(!e)throw new ue;if(t!==e.id)throw new de({chain:e,currentChainId:t})}function J(e,{docsPath:t,...r}){const n=(()=>{const d=le(e,r);return d instanceof fe?e:d})();return new he(n,{docsPath:t,...r})}function qe(e){const{source:t}=e,r=new Map,n=new D(8192),d=new Map,u=({address:o,chainId:a})=>`${o}.${a}`;return{async consume({address:o,chainId:a,client:l}){const f=u({address:o,chainId:a}),s=this.get({address:o,chainId:a,client:l});this.increment({address:o,chainId:a});const y=await s;return await t.set({address:o,chainId:a},y),n.set(f,y),y},async increment({address:o,chainId:a}){const l=u({address:o,chainId:a}),f=r.get(l)??0;r.set(l,f+1)},async get({address:o,chainId:a,client:l}){const f=u({address:o,chainId:a});let s=d.get(f);return s||(s=(async()=>{try{const p=await t.get({address:o,chainId:a,client:l}),c=n.get(f)??0;return c>0&&p<=c?c+1:(n.delete(f),p)}finally{this.reset({address:o,chainId:a})}})(),d.set(f,s)),(r.get(f)??0)+await s},reset({address:o,chainId:a}){const l=u({address:o,chainId:a});r.delete(l),d.delete(l)}}}function Le(){return{async get(e){const{address:t,client:r}=e;return G(r,{address:t,blockTag:"pending"})},set(){}}}const Ge=qe({source:Le()}),Be="0x6492649264926492649264926492649264926492649264926492649264926492",He="0x0000000000000000000000000000000000000000000000000000000000000000";function Ve(e){const{address:t,data:r,signature:n,to:d="hex"}=e,u=A([pe([{type:"address"},{type:"bytes"},{type:"bytes"}],[t,r,n]),Be]);return d==="hex"?u:we(u)}const _=new D(128);async function Oe(e,t){var g,T,F,q;const{account:r=e.account,chain:n=e.chain,accessList:d,authorizationList:u,blobs:o,data:a,gas:l,gasPrice:f,maxFeePerBlobGas:s,maxFeePerGas:y,maxPriorityFeePerGas:p,nonce:c,type:w,value:m,...h}=t;if(typeof r>"u")throw new H({docsPath:"/docs/actions/wallet/sendTransaction"});const i=r?M(r):null;try{me(t);const C=await(async()=>{if(t.to)return t.to;if(t.to!==null&&u&&u.length>0)return await ge({authorization:u[0]}).catch(()=>{throw new v("`to` is required. Could not infer from `authorizationList`.")})})();if((i==null?void 0:i.type)==="json-rpc"||i===null){let N;n!==null&&(N=await E(e,V,"getChainId")({}),Fe({currentChainId:N,chain:n}));const z=(F=(T=(g=e.chain)==null?void 0:g.formatters)==null?void 0:T.transactionRequest)==null?void 0:F.format,B=(z||ye)({...be(h,{format:z}),accessList:d,authorizationList:u,blobs:o,chainId:N,data:a,from:i==null?void 0:i.address,gas:l,gasPrice:f,maxFeePerBlobGas:s,maxFeePerGas:y,maxPriorityFeePerGas:p,nonce:c,to:C,type:w,value:m}),O=_.get(e.uid),Y=O?"wallet_sendTransaction":"eth_sendTransaction";try{return await e.request({method:Y,params:[B]},{retryCount:0})}catch(U){if(O===!1)throw U;const x=U;if(x.name==="InvalidInputRpcError"||x.name==="InvalidParamsRpcError"||x.name==="MethodNotFoundRpcError"||x.name==="MethodNotSupportedRpcError")return await e.request({method:"wallet_sendTransaction",params:[B]},{retryCount:0}).then(I=>(_.set(e.uid,!0),I)).catch(I=>{const R=I;throw R.name==="MethodNotFoundRpcError"||R.name==="MethodNotSupportedRpcError"?(_.set(e.uid,!1),x):R});throw x}}if((i==null?void 0:i.type)==="local"){const N=await E(e,Te,"prepareTransactionRequest")({account:i,accessList:d,authorizationList:u,blobs:o,chain:n,data:a,gas:l,gasPrice:f,maxFeePerBlobGas:s,maxFeePerGas:y,maxPriorityFeePerGas:p,nonce:c,nonceManager:i.nonceManager,parameters:[...Ce,"sidecars"],type:w,value:m,...h,to:C}),z=(q=n==null?void 0:n.serializers)==null?void 0:q.transaction,L=await i.signTransaction(N,{serializer:z});return await E(e,xe,"sendRawTransaction")({serializedTransaction:L})}throw(i==null?void 0:i.type)==="smart"?new P({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new P({docsPath:"/docs/actions/wallet/sendTransaction",type:i==null?void 0:i.type})}catch(C){throw C instanceof P?C:J(C,{...t,account:i,chain:t.chain||void 0})}}const Q="0x5792579257925792579257925792579257925792579257925792579257925792",X=b(0,{size:32});async function Ke(e,t){const{account:r=e.account,capabilities:n,chain:d=e.chain,experimental_fallback:u,experimental_fallbackDelay:o=32,forceAtomic:a=!1,id:l,version:f="2.0.0"}=t,s=r?M(r):null,y=t.calls.map(p=>{const c=p,w=c.abi?Ee({abi:c.abi,functionName:c.functionName,args:c.args}):c.data;return{data:c.dataSuffix&&w?j([w,c.dataSuffix]):w,to:c.to,value:c.value?b(c.value):void 0}});try{const p=await e.request({method:"wallet_sendCalls",params:[{atomicRequired:a,calls:y,capabilities:n,chainId:b(d.id),from:s==null?void 0:s.address,id:l,version:f}]},{retryCount:0});return typeof p=="string"?{id:p}:p}catch(p){const c=p;if(u&&(c.name==="MethodNotFoundRpcError"||c.name==="MethodNotSupportedRpcError"||c.name==="UnknownRpcError"||c.details.toLowerCase().includes("does not exist / is not available")||c.details.toLowerCase().includes("missing or invalid. request()")||c.details.toLowerCase().includes("did not match any variant of untagged enum")||c.details.toLowerCase().includes("account upgraded to unsupported contract")||c.details.toLowerCase().includes("eip-7702 not supported")||c.details.toLowerCase().includes("unsupported wc_ method")||c.details.toLowerCase().includes("feature toggled misconfigured"))){if(n&&Object.values(n).some(g=>!g.optional)){const g="non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";throw new Ne(new v(g,{details:g}))}if(a&&y.length>1){const i="`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";throw new ve(new v(i,{details:i}))}const w=[];for(const i of y){const g=Oe(e,{account:s,chain:d,data:i.data,to:i.to,value:i.value?k(i.value):void 0});w.push(g),o>0&&await new Promise(T=>setTimeout(T,o))}const m=await Promise.allSettled(w);if(m.every(i=>i.status==="rejected"))throw m[0].reason;const h=m.map(i=>i.status==="fulfilled"?i.value:X);return{id:j([...h,b(d.id,{size:32}),Q])}}throw J(p,{...t,account:s,chain:t.chain})}}async function Ue(e,t){async function r(s){if(s.endsWith(Q.slice(2))){const p=Me($(s,-64,-32)),c=$(s,0,-64).slice(2).match(/.{1,64}/g),w=await Promise.all(c.map(h=>X.slice(2)!==h?e.request({method:"eth_getTransactionReceipt",params:[`0x${h}`]},{dedupe:!0}):void 0)),m=w.some(h=>h===null)?100:w.every(h=>(h==null?void 0:h.status)==="0x1")?200:w.every(h=>(h==null?void 0:h.status)==="0x0")?500:600;return{atomic:!1,chainId:W(p),receipts:w.filter(Boolean),status:m,version:"2.0.0"}}return e.request({method:"wallet_getCallsStatus",params:[s]})}const{atomic:n=!1,chainId:d,receipts:u,version:o="2.0.0",...a}=await r(t.id),[l,f]=(()=>{const s=a.status;return s>=100&&s<200?["pending",s]:s>=200&&s<300?["success",s]:s>=300&&s<700?["failure",s]:s==="CONFIRMED"?["success",200]:s==="PENDING"?["pending",100]:[void 0,s]})();return{...a,atomic:n,chainId:d?W(d):void 0,receipts:(u==null?void 0:u.map(s=>({...s,blockNumber:k(s.blockNumber),gasUsed:k(s.gasUsed),status:ze[s.status]})))??[],statusCode:f,status:l,version:o}}async function Je(e,t){var l;const{account:r=e.account,chainId:n,nonce:d}=t;if(!r)throw new H({docsPath:"/docs/eip7702/prepareAuthorization"});const u=M(r),o=(()=>{if(t.executor)return t.executor==="self"?t.executor:M(t.executor)})(),a={address:t.contractAddress??t.address,chainId:n,nonce:d};return typeof a.chainId>"u"&&(a.chainId=((l=e.chain)==null?void 0:l.id)??await E(e,V,"getChainId")({})),typeof a.nonce>"u"&&(a.nonce=await E(e,G,"getTransactionCount")({address:u.address,blockTag:"pending"}),(o==="self"||o!=null&&o.address&&Ie(o.address,u.address))&&(a.nonce+=1)),a}class je extends v{constructor(t){super(`Call bundle failed with status: ${t.statusCode}`,{name:"BundleFailedError"}),Object.defineProperty(this,"result",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.result=t}}async function Qe(e,t){const{id:r,pollingInterval:n=e.pollingInterval,status:d=({statusCode:m})=>m===200||m>=300,retryCount:u=4,retryDelay:o=({count:m})=>~~(1<<m)*200,timeout:a=6e4,throwOnFailure:l=!1}=t,f=Re(["waitForCallsStatus",e.uid,r]),{promise:s,resolve:y,reject:p}=Se();let c;const w=Pe(f,{resolve:y,reject:p},m=>{const h=_e(async()=>{const i=g=>{clearTimeout(c),h(),g(),w()};try{const g=await ke(async()=>{const T=await E(e,Ue,"getCallsStatus")({id:r});if(l&&T.status==="failure")throw new je(T);return T},{retryCount:u,delay:o});if(!d(g))return;i(()=>m.resolve(g))}catch(g){i(()=>m.reject(g))}},{interval:n,emitOnBegin:!0});return h});return c=a?setTimeout(()=>{w(),clearTimeout(c),p(new We({id:r}))},a):void 0,await s}class We extends v{constructor({id:t}){super(`Timed out while waiting for call bundle with id "${t}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}function Xe(e){const{r:t,s:r}=Ae.Signature.fromCompact(e.slice(2,130)),n=+`0x${e.slice(130)}`,[d,u]=(()=>{if(n===0||n===1)return[void 0,n];if(n===27)return[BigInt(n),0];if(n===28)return[BigInt(n),1];throw new Error("Invalid yParityOrV value")})();return typeof d<"u"?{r:b(t,{size:32}),s:b(r,{size:32}),v:d,yParity:u}:{r:b(t,{size:32}),s:b(r,{size:32}),yParity:u}}export{je as B,We as W,Xe as a,Be as b,qe as c,Oe as d,De as e,Fe as f,Ke as g,Ue as h,Ge as n,Je as p,Ve as s,Qe as w,He as z};
